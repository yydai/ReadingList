* Writing GNU Emacs Extensions学习笔记

** Chapter 1, Customizing Emacs
   This chapter introduces basic Emacs customizations, and teaches some Emacs Lisp along the way. 

*** Fully-parenthesized prefix notation
    All expressions and function calls in Lisp are surrounded by parentheses.
    "Prefix notation" means that the operator precedes the operands. When the
    operator is between the operands, it's called "infix notation."

*** Garbage collection
    Lisp is a garbage-collected language, which means that Lisp itself
    automatically reclaims the memory used by your program's data structures.

*** Binding Keystrokes to Commands
    The function global-set-key takes two arguments: the keysequence to bind,
    and the command to bind it to. 

    =(global-set-key keysequence command)= ==> =(global-set-key "\M-?" command)=

*** Evaluating Lisp Expressions
    There are several ways to explicitly evaluate Lisp expressions.
    1. put the lisp expressions in a file, and then load the file to emacs.
       You can use the command like this:

       =M-x load-file RET <file-name> RET=

    2. use the command: =eval-last-sexp=, which bound to the C-x C-e

    3. use the *scratch* buffer

*** Apropos
    Before wrapping up this first example, let's discuss Emacs's most important
    online help facility, apropos.
    
** Chapter 2, Simple New Commands
   In this chapter we'll develop several very small Lisp functions and commands.

*** Traversing Windows
    =C-x o= bound to the function of =other-window= ,moves the cursor from one
    Emacs window into the next. So I chose C-x C-n for "next window" and C-x C-p
    for "previous window."
   
    =(global-set-key "\C-x\C-n" 'other-window)=
    
    Defining a function called other-window-backward

    #+BEGIN_SRC lisp
    (defun other-window-backward ( )
      "Select the previous window."
      (interactive)
      (other-window -1))
    #+END_SRC

    =(global-set-key "\C-x\C-p" 'other-window-backward)=

*** Parameterizing Other-window Backward
    This keybinding does what we need, but we can improve on it a bit. Now, we
    will a parameter of n to the function. If we want to pass a parameter to it,
    we can use =C-u <parameter> C-x C-n=. For example, C-u 2 C-x C-n means "move
    to the second window following this one."
    
    #+BEGIN_SRC lisp
    (defun other-window-backward(n)
      "Select Nth previous window."
      (interactive "p")
      (other-window (- n)))
    #+END_SRC

    An =interactive= command is a kind of Lisp function. That means that the
    command may take arguments. Passing arguments to a function from lisp is
    easy. but what if the function is invoked as an interactive command? Where
    do the arguments come from then? Answering this question is the purpose of
    the =interactive= declaration. The code letter ="p"= used in this example
    means, "if there is a prefix argument, interpret it as a number, and if
    there is no prefix argument, interpret that as the number 1."

*** Making the Argument Optional
    #+BEGIN_SRC lisp
     (defun other-window-backward (&optional n)
       "Select Nth previous window."
       (interactive "p")
       (if n
       (other-window (- n)) ;if n is non-nil
       (other-window -1))) ;if n is nil

    #+END_SRC

    The keyword &optional appearing in a parameter list means that all
    subsequent parameters are optional.
    
    we can rewriten the exp to this:
    =(other-window (if n (- n) -1))=, and more better is this:
    =(other-window (- (if n n 1)))=

*** Logical Expressions   
     An old Lisp programmers' trick can now be used to make this expression even
     more concise:
     =(if n n 1)= == =(or n 1)=
     
     Lisp's =or= has an extra bit of usefulness: it evaluates each of its
     arguments in order until it finds one that's non-nil, then it returns that
     value. If it doesn't find one, it returns =nil=.

     #+BEGIN_SRC lisp
       (if a a                                 ;; if a is true, return a
         (if b b                               ;; else if b is true, return b
           ...
             (if y y z)))                      ;; else if y is true, return y, else z
     #+END_SRC
     can be changed to the following form.
     #+BEGIN_SRC lisp
     (or a b ... y z)
     #+END_SRC

     Similarly,
     #+BEGIN_SRC lisp
     (if a
       (if b
         ...
           (if y z)))
     #+END_SRC
     can be also written as
     #+BEGIN_SRC lisp
     (and a b ... y z)
     #+END_SRC
     also:
     =(if (and a b ... y) z)= == =(and a b ... y z)=, but the first one is more better to read for human.

*** The better other-window-backward
    #+BEGIN_SRC lisp
     (defun other-window-backward (&optional n)
       "Select Nth previous window."
       (interactive "p")
       (other-window (- (or n 1)))
    #+END_SRC

    But the best definition of all-the most Emacs-Lisp like-turns out to be:

    #+BEGIN_SRC lisp
    (defun other-window-backward (&optional n)
      "Select Nth previous window."
      (interactive "P")
      (other-window (- (prefix-numberic-value n))))
    #+END_SRC

    where =prefix-numberic-value= is a build-in function.

    You should notice the ="P"= instead of ="p" in previoud version. The capital
    P means "when called interactively, leave the prefix argument in raw form
    and assign it to n." Where =prefix-numberic-value= is a build-in function.

*** Other Cursor and Text Motion Commands
    Here are a few more easy commands with their suggested keybindings.

    #+BEGIN_SRC lisp
    (defun point-to-top()
      "Put point on top line of window."
      (interactive)
      (move-to-window-line 0))

    (global-set-key "\M-," 'point-to-top)

    (global-set-key "\C-x," 'tags-loop-continue)
    #+END_SRC

    The next function makes the cursor jump to the bottom left of the window it's in.
    #+BEGIN_SRC lisp
    (defun point-to-bottom()
      "Put point at the beginning of last visible line."
      (interactive)
      (move-to-window-line -1))

    (global-set-key "M-." 'point-to-bottom)
    #+END_SRC

    This command scrolls the window so that whichever line the cursor is one
    becomes the top line in the window. The keybinding replaces =shell-command=

    #+BEGIN_SRC lisp
    (defun line-to-top()
      "Move current line to top of window."
      (interactive)
      (recenter 0))
    (global-set-key "\M-!" 'line-to-top)
    #+END_SRC
    
*** Clobbering Symbolic Links
   So far, the function we've written have been very simple. Let's look at an example now where more programming is required.

   In UNIX, a symbolic link, or symlink, is a file that refers to another file
   by name. When you ask for the contens of a symlink, you actually get the
   contents of the real file named by the symlink.

   Suppose you visit a file in Emacs that is really a symlink to some other
   file. You make some changes and Press =C-x C-s= to save the buffer. What
   should Emacs do?
    1. Replace the symbolic link with the edited version of the file, breaking the link but leaving the original link target alone.
    2. Overwrite the file pointed to by the symbolic link.
    3. Prompt you to choose one of the above actions.
    4. Something else altoge

   Here's what I do: when I visit a file that's really a symlink, I have Emacs
   automatically make the buffer read-only. This causes a "Buffer is read-only"
   error as soon as I try to change anything in the buffer. Then I choose how to
   proceed using one of two special commands I've designed.

*** Hooks
    For Emacs to make the buffer read-only when I first visit the file, I have
    to somehow tell Emacs, "execute a certern piece of Lisp code whenever I
    visit a file." The action of visiting a file should trigger a function I
    write. This is where hooks come in.

    The function =add-hook= adds a function to a hook variable. Here's a function to add to =find-file-hooks=:
    #+BEGIN_SRC lisp
    (defun read-only-if-symlink()
      (if (file-symlink-p buffer-file-name)
          (progn
            (setq buffer-read-only t)
            (message "File is a symlink"))))
    #+END_SRC
    
    This function tests whether current buffer's file is symlink.
    - The function =file-symlink-p= tests whether its argument, which is a string naming a file, refers to a symbolic link.
    - If =buffer-file-name= does refer to a symlink, there are two things we want to do:
      make the buffer read-only, and display a message.
    - A =progn= expression evaluates each of its subexpressions in order and returns the value of the last one.

    Now that we've defined =read-only-if-symlink=, we can call

    #+BEGIN_SRC lisp
    (add-hook 'find-file-hooks 'read-only-if-symlink)
    #+END_SRC
    to add it to the list of functions that are called whenever a new file is visited.

*** Anonymous Functions

    If the function won't ever be called from anywhere else, the better way is
    to define a function without giving it a name. Such functions are known as 
    anonymous functions.
    #+BEGIN_SRC lisp
    (lambda ()
        (if (file-symlink-p buffer-file-name)
            (progn
               (setq buffer-read-only t)
               (message "File is a symlink"))))
    #+END_SRC
    so:
    #+BEGIN_SRC lisp
    (add-hook 'find-file-hooks
      '(lambda ()
        (if (file-symlink-p buffer-file-name)
            (progn
               (setq buffer-read-only t)
               (message "File is a symlink")))))
    #+END_SRC
    
    Now only find-file-hooks has access to the function; on other code is able to call it.

    There's one reason not to use anonymous functions in hooks. IF you ever wish to remove a function from a hook,
    you need to refer to it by name in a call to remove-hook, like so:

    #+BEGIN_SRC lisp
       (remove-hook 'find-file-hooks 'read-only-if-symlink)
    #+END_SRC
*** Handing the symlink
    When Emacs alerts me that I'm editing a symlink, I may wish to replace the buffer with one visiting the 
    target of the link instead; or I may wish to "clobber" the symlink and visit that.

    #+BEGIN_SRC lisp
    (defun visit-target-instead()
      "Replace this buffer with a buffer visiting the link target."
      (interactive)
      (if buffer-file-name
          (let ((target (file-symlink-p buffer-file-name)))
            (if target
                (find-alternate-file target)
                (error "Not visiting a symlink")))
          (error "Not visiting a file")))

     (defun clobber-symlink()
        "Replace symlink with a copy of the file."
        (interactive)
        (if buffer-file-name
            (let ((target (file-symlink-p buffer-file-name)))
            (if target
                (if (yes-or-no-p (format "Replace %s with %s?"
                                         buffer-file-name
                                         target))
                    (progn
                    (delete-file buffer-file-name)
                    (write-file buffer-file-name)))
                 (error "Not visiting a file")))
    #+END_SRC


    To be continue...(P35)




** Chapter 2, Simple New Commands
** Chapter 3, Cooperating Commands

** Chapter 4, Searching and Modifying Buffers

** Chapter 5, Lisp Files

** Chapter 6, Lists

** Chapter 7, Minor Mode


   
